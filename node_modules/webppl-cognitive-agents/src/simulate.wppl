/** This file contains a few functions useful for simulating
 * execution of games specified separately by defining getGameSetup.
 * It is expected that most users will want to define some scenarios,
 * each specifying initial setup of agents, and use 'simulateScenarios'
 * to simulate the unfolding of such scenario. */

/** Each scenario should contain the following elements:
 * - *name* of the scenario, possibly including a short description
 * - *agents* - array of agent parameters, specifying setup of each agent
 * - *gameSpecificParams* - parameters to be passed to getGameSetup
 * - *startingState*? - state from which to start simulation (optional)
 * - *options* - specifies simulation parameters such as
 *    - *horizon*
 *    - *beliefRepresentation*
 * */

/**
 *
 * @param scenarios
 * @param getGameSetup
 * @param namesOpt | optional but strongly recommended
 * @param callbacksOpt | (optional) object of the form
 * {
 *   setup: <function>,
 *   periodic: <function>,
 *   final: <function>
 * }
 * containing functions to be called at the start,at each step and at
 * the end of executing each scenario. That allows some code, mainly in the form
 * of informational print statements, to be called as the game executes.
 * Each of the specified functions should 
 */
let simulateScenarios = function (scenarios, getGameSetup, namesOpt, callbacksOpt) {
  /** First check params passed correctly */
  assertIsArray(scenarios, ANY_TYPE, -1,
    "simulateScenarios(): expected scenarios array, found: " + toString(scenarios))
  assertDefined(getGameSetup, "simulateScenarios(): getGameSetup undefined")
  if (scenarios.length == 0) return []
  let nextScenario = scenarios[0]
  let gameSetup = getGameSetup(nextScenario.gameSpecificParams)
  let names = namesOpt || rangeArray(0, gameSetup.params.numberOfAgents)
  let trajectory = simulateScenario(nextScenario, gameSetup, names, callbacksOpt)
  let otherTrajectories = simulateScenarios(
    scenarios.slice(1), getGameSetup, names, callbacksOpt)
  return [trajectory].concat(otherTrajectories)
}

/**
 * @param scenario has format
 * {
 * name: <name of scenario>,
 * options: <array of params to be passed to 'getGameSetup'>
 * agents: array of initial setups of agents of the form
 *   {
 *     params: {
         goalCoeffs: <array of goal coeffs>,
         metaParams: {
           alpha: <val>,
           discountFactor: <val>,
           lookAhead: <val>
         }
       },
       initialState: {
         belief: <array of beliefs>,
         mentalEstimations: <array of arrays of estimations (dists)>,
         metaParamsEstimations
       }
     }
 * }
 */
let simulateScenario = function (scenario, gameSetup, names, callbacksOpt) {
  /** here we're validating user input */
  validateScenario(scenario)
  explain(stringInABox("Scenario: " + scenario.name))
  let agentsSetup = scenario.agents
  printAgentsSetup(agentsSetup, names)
  let game = makeCSMG(gameSetup, scenario.options)
  let agents = mapIndexed(function (i, agentSetup) {
    return makeAgent(agentSetup.params, i, agentSetup.initialState, game)
  }, agentsSetup)
  let trajectory = simulate(game, agents, scenario.options.horizon, names, callbacksOpt, scenario.startingState)
  explain("Scenario " + scenario.name + " computed trajectory: ")
  explain(arrayToString(trajectory))
  return trajectory
}

let validateScenario = function(scenario) {
  assertDefined(scenario, "simulateScenario: scenario undefined")

  /** NAME */
  let name = assertDefined(scenario.name,
    "simulateScenario: scenario.name undefined")

  let failMsgInto = "simulateScenario() for scenario: " + name + ": "

  /** OPTIONS */
  let options = assertDefined(scenario.options,
    failMsgInto + "scenario.options undefined")
  let horizon = assertDefined(options.horizon,
    failMsgInto + "options.horizon undefined")
  assertHasType(horizon, INT_TYPE,
    failMsgInto + "options.horizon has wrong type")
  let beliefRep = assertDefined(options.beliefRepresentation,
    failMsgInto + "options.beliefRep undefined")
  assertHasType(beliefRep, STRING_TYPE,
    failMsgInto + "options.beliefRep has wrong type")
  assert(beliefRep === "discrete" || beliefRep === 'dirichlet',
    failMsgInto + "beliefRep should be discrete or dirichlet")

  let validateAgent = function(agentSetup, agentID, agentsNumber) {
    let agentFailMsgIntro = "agent " + agentsNumber + ": "

    /** PARAMS */
    let params = assertDefined(agentSetup.params,
      agentFailMsgIntro + "params not specified")
    let goalCoeffs = assertDefined(params.goalCoeffs,
      agentFailMsgIntro + "goalCoeffs undefined")
    assertIsArray(goalCoeffs, NUMBER_TYPE, -1,
      agentFailMsgIntro + "goalCoeffs not as expected")

    /** METAPARAMS */
    let metaParams = assertDefined(params.metaParams,
      agentFailMsgIntro + "meta params undefined")
    let alpha = assertDefined(metaParams.alpha,
      agentFailMsgIntro + "alpha undefined")
    assertHasType(alpha, NUMBER_TYPE,
      agentFailMsgIntro + "alpha is not a number!")
    assert(alpha >= 0,
      agentFailMsgIntro + "alpha can't be negative!")
    let discountFactor = assertDefined(metaParams.discountFactor,
      agentFailMsgIntro + "discount factor undefined")
    assertHasType(discountFactor, NUMBER_TYPE,
      agentFailMsgIntro + "discount factor is not a number!")
    assert(discountFactor >= 0 && discountFactor <= 1,
      agentFailMsgIntro + "discount factor must be between 0 and 1!")
    let lookAhead = assertDefined(metaParams.lookAhead,
      agentFailMsgIntro + "lookahead undefined")
    assertHasType(lookAhead, INT_TYPE,
      agentFailMsgIntro + "lookahead must be an integer!")
    assert(lookAhead >= 0,
      agentFailMsgIntro + "lookahead can't be negative!")

    /** INITIAL STATE */
    let initialState = assertDefined(agentSetup.initialState,
      agentFailMsgIntro + "initial state undefined")
    let belief = assertDefined(initialState.belief,
      agentFailMsgIntro + "belief undefined")
    assertIsArray(belief, ANY_TYPE, agentsNumber,
      agentFailMsgIntro + "belief must be array indexed by" +
      " agentID, found: " + toString(belief))
    let mentalEstimations = assertDefined(initialState.mentalEstimations,
      agentFailMsgIntro + "mental estimations undefined")
    assertIsArray(mentalEstimations, OBJECT_TYPE, agentsNumber,
      agentFailMsgIntro + "mental estimations must be an array " +
      "of distributions indexed by agentID; found: " + toString(mentalEstimations))
    let metaParamsEstimations = assertDefined(initialState.metaParamsEstimations,
      agentFailMsgIntro + "metaParamsEstimations undefined")
    let alphaEst = assertDefined(metaParamsEstimations.alpha,
      agentFailMsgIntro + "alpha estimations undefined")
    assertIsArray(alphaEst, OBJECT_TYPE, agentsNumber,
      agentFailMsgIntro + "alpha estimations should be an array" +
      " of distributions indexed by agentID; found: " + toString(alphaEst))
    let lookaheadEst = assertDefined(metaParamsEstimations.lookAhead,
      agentFailMsgIntro + "lookahead estimations undefined")
    assertIsArray(lookaheadEst, OBJECT_TYPE, agentsNumber,
      agentFailMsgIntro + "lookahead estimations should be an array" +
      " of distributions indexed by agentID; found: " + toString(lookaheadEst))
    let discountFactorEst = assertDefined(metaParamsEstimations.discountFactor,
      agentFailMsgIntro + "discount factor estimations undefined")
    assertIsArray(discountFactorEst, OBJECT_TYPE, agentsNumber,
      agentFailMsgIntro + "discount factor estimations should be an array" +
      " of distributions indexed by agentID; found: " + toString(discountFactorEst))
  }

  let validateAgents = function(agentsArr, agentID, agentsNumber) {
    if (agentsArr.length === 0) return
    validateAgent(agentsArr[0], agentID, agentsNumber)
    validateAgents(agentsArr.slice(1), agentID + 1, agentsNumber)
  }
  /** AGENTS */
  let agents = assertDefined(scenario.agents,
    failMsgInto + "scenario.agents undefined")
  let noOfAgents = agents.length
  validateAgents(agents, 0, noOfAgents)
}


/** Simulate execution of *game* played by *agents* for *horizon*
 * steps. Additionally, optional arguments allow one to:
 * - specify a starting state other than initial state
 * - provide functions that will be called at the start
 * of simulation (callbacksOpt.setup) and at every iteration
 * (callbacksOpt.periodic)
 * - namesOpt
 *
 * @param game | instance of CSMG created by calling makeCSMG()
 * @param agents | array of agents, each created by calling makeAgent()
 * @param horizon | integer specifying number of steps
 * @param names | array of names of agents
 * @param callbacksOpt (optional) | functions to call during simulation
 * @param stateOpt (optional)
 * @returns an array of (state, action) pairs
 */
let simulate = function (game, agents, horizon, names, callbacksOpt, stateOpt) {
  assertDefined(game.initialState,
    "simulate(): game.initialState undefined")
  let startingState = stateOpt || game.initialState
  explain("Simulation starts.")
  let stateToString = game.API.stateToString
  debug("startingState: " + stateToString(startingState))
  explain("Agents: " + arrayToString(names))
  if (callbacksOpt !== undefined && callbacksOpt.setup !== undefined) {
    let setup = callbacksOpt.setup
    setup(game, agents, startingState, names)
  }
  let traj = trajectory(game, startingState, agents, horizon, names, callbacksOpt)
  if (callbacksOpt !== undefined && callbacksOpt.final !== undefined) {
    let final = callbacksOpt.final
    let finalState = traj[traj.length - 1][0]
    final(game, agents, finalState, names)
  }
  return traj
}

let trajectory = function (game, startingState, agents, timeLeft, names, callbacksOpt) {
  let trajectoryRec = function(state, timeLeft) {
    if (timeLeft > 0) {
      let turn = assertDefined(game.API.turn,
        "trajectory(): game.API.turn undefined")
      let actingPlayer = assertDefined(agents[turn(state)],
      "trajectory(): failed to compute acting player as element" +
        " at index " + turn(state) + " in array " + toString(agents))
      explain("New iteration. Time left: " + timeLeft + ", " + names[turn(state)] + " to act")
      let act = actingPlayer.act
      let start = _.now()
      debug(state)
      let action = sample(act(state))
      let end = _.now()
      explain("\nAction computed: " + action + ". Took " + (end - start) + " msec\n")
      let transitionFn = game.transitionFn
      let nextState = sample(transitionFn(state, action))
      if (callbacksOpt !== undefined && callbacksOpt.periodic !== undefined) {
        let periodic = callbacksOpt.periodic
        periodic(game, agents, nextState, names)
      }
      return [[state, action]].concat(trajectoryRec(nextState,timeLeft - 1))
    }
    return []
  }
  trajectoryRec(startingState, timeLeft)
}

let printAgentsSetup = function (agents, names) {
  assertEqual(agents.length, names.length,
    "printAgents(): expecting names for all agents and no more")
  if (agents.length === 0) return
  explain("Agent: " + names[0])
  explain("Params: ")
  explain(agents[0].params)
  explain("Initial state: ")
  explain(agents[0].initialState)
  explain("-----------------------------------------")
  printAgentsSetup(agents.slice(1), names.slice(1))
}

/** Few auxiliary functions to facilitate creating scenarios */
let generateParams = function(goalCoeffs, alpha, discountFactor, lookAhead) {
  return {
    /** format [physical goal, mental goal] */
    goalCoeffs,
    metaParams: {
      alpha,
      discountFactor,
      lookAhead
    }
  }
}

/** note that belief and mentalEstimations have to be filled in later */
let generateInitialState = function(agentID, numberOfAgents, alphaExp, discountExp, lookAheadExp) {
  let alpha = repeat(numberOfAgents, function() {return Delta({v: alphaExp})})
  let discountFactor = repeat(numberOfAgents, function() {return Delta({v: discountExp})})
  let lookAhead = repeat(numberOfAgents, function() {return Delta({v: lookAheadExp})})
  return {
    belief: repeat(numberOfAgents, getUndefined),
      // function() { return Delta({v: undefined})}),
    mentalEstimations : repeat(numberOfAgents, getUndefined),
    metaParamsEstimations: {
      alpha: arrayReplace(alpha, agentID, undefined),
      lookAhead: arrayReplace(lookAhead, agentID, undefined),
      discountFactor: arrayReplace(discountFactor, agentID, undefined)
    }
  }
}