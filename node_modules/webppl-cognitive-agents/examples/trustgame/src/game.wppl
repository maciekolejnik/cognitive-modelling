/**
Game structure
- we refer to the two players as *investor* and *investee*
- state consists of
  * turn: indicates whether next move is investing or returning
  * timeLeft: how many time steps are left in the game (-1 means infinite horizon)
  * investments: history of amounts sent by investor (most recent in position 0)
  * returns: history of amounts sent by investee (most recent in position 0)

  //* endowments: a dictionary {'investor': x, 'investee': y} specifying
    how much both players received in endowments in this stage

- we allow integer transfers not exceeding money available to player
- gameParams configure the game as follows:
  * investorEndowment: how much does investor get at the start of each round
  * investeeEndowment: how much does investee get at the start of each round
*/

/**
var params = {
  endowments : {
    'investor': 0,
    'investee': 0
  },
  k: 0,
  beliefRepresentation: <discrete/dirichlet>
}
*/
let makeTrustCSMG = function(gameSpecificParams) {
  let endowments = gameSpecificParams.endowments
  let investorEndowment = endowments.investor
  let k = gameSpecificParams.k
  /**********************************
   *     Some auxiliary functions   *
   * ********************************/

  /** Compute endowment of agents in a state
   * @param state
   * @param params
   * @returns {investor: number, investee: number}
   */
  let endowment = function(state) {
    if (state.turn == "investor") {
      return endowments
    }
    return {
      investor: 0,
      investee: 0
    }
  }

  /** Computes the monetary transfer for each agent (positive or negative)
   * when *action* is taken in *state*
   * Params:
   *  - *state*
   *  - *action*
   * Returns
   *   an dictionary indexed by agent with money amount received (positive) or
   *   given away (negative)
   */
  let transfer = function(state, action) {
    let investor = action * ((state.turn == "investor") ? -1 : 1)
    return {
      'investor': investor,
      'investee': -investor
    }
  }

  /** Compute maximal possible amount that can be transferred from a given state */
  let maxPossibleTransfer = function(state) {
    return (state.turn == 'investor') ? investorEndowment :
      state.investments[0] * k
  }

  /** Game mechanics */
  let actions = function(state) {
    if (state.turn == 'investor') {
      return rangeArray(0, investorEndowment)
      // return [0,params.endowments.investor]
    }
    console.assert(state.investments.length > 0,
      "Investee turn, but no past investments recorded")
    return rangeArray(0, state.investments[0] * k)
  }

  let transitionFn = function(state, action) {
    info("transitionFn(state: " + stateToString(state) + ", action: " + action + ")")
    let turn = state.turn
    let nextTurn = (turn == 'investor') ? 'investee' : 'investor'
    let nextInvestments = (turn == 'investor') ?
      [action].concat(state.investments) : state.investments
    let nextReturns = (turn == 'investee') ?
      [action].concat(state.returns) : state.returns
    let result = {
      turn: nextTurn,
      investments: nextInvestments,
      returns: nextReturns
    }
    info("transitionFn(state: " + stateToString(state) + ", action: " + action + ")"
      + ": computed " + stateToString(result))
    return Delta({v: result})
  }

  let turn = function (state) {
    return (state.turn === 'investor') ? 0 : 1
  }

  /** Compulsory API of a game */
  let API = function() {
    let getPreviousState = function (state) {
      if (isInitial(state)) return state
      let prevTurn = (state.turn == 'investor') ? 'investee' : 'investor'
      // var prevTimeLeft = state.timeLeft + 1
      let prevInvestments = (prevTurn == 'investor') ? state.investments.slice(1) : state.investments
      let prevReturns = (prevTurn == 'investee') ? state.returns.slice(1) : state.returns
      return {
        turn: prevTurn,
        // timeLeft: prevTimeLeft,
        investments: prevInvestments,
        returns: prevReturns
      }
    }

    let getLastAction = function (state) {
      console.assert(!isInitial(state), "Calling previousAction on initial state")
      if (state.investments.length > state.returns.length)
        return state.investments[0]
      else
        return state.returns[0]
    }

    let isInitial = function (state) {
      return state.investments.length === 0 && state.returns.length === 0
    }

    let stateToString = function (state) {
      return "{invs: " + arrayToString(state.investments) +
        ", rets: " + arrayToString(state.returns) + "}"
    }

    let API = {
      getPreviousState,
      getLastAction,
      isInitial,
      turn,
      stateToString
    }

    return API
  }()



  /** Physical rewards structure
   *  This is a relatively simple component which models state and
   *  action rewards that agents receive - these are the typical
   *  physical rewards familiar from other settings
   */
  let physicalRewardStructure = function() {

    /** State rewards
     *
     * @param state
     * @returns {{investor: array[reward], investee: array[reward]}}
     */
    let stateRewards = function(state) {
      let endowments = endowment(state)
      return [
        [endowments.investor],
        [endowments.investee]
      ]
    }

    /** Action rewards
     *
     * @param state
     * @param action
     * @returns {{investor: array[number], investee: array[number]}}
     */
    let actionRewards = function(state, action) {
      let transfers = transfer(state, action)
      return [
        [transfers.investor],
        [transfers.investee]
      ]
    }

    return {
      actionRewards,
      stateRewards,
      quantity: 1
    }
  }()

  /** Mental state dynamics model
   *  It consists of two components:
   *  (i) Heuristics agents use to estimate mental state of their opponents.
   *    This should be specified as an array of update functions, one for each
   *    mental state. Each update function has
   *    @type (mentalStateValue, agent, state, action) -> newMentalStateValue
   *  (ii) Mental state computation, i.e. how can actual mental state of an
   *    agent be computed. Each such function that computes some mental state
   *    of an agent has
   *    @type (state, belief) -> mentalStateValue
   */
  let mentalStateDynamics = function() {
    let getLastAction = API.getLastAction
    let getPreviousState = API.getPreviousState

    /** updateTrustEstimation
     * captures the dynamics of how one agent estimates changes of their
     * opponent's trust upon them taking an action.
     *
     * @param trust | previous value of trust
     * @param estimatingAgentID |
     *   identifies the agent who estimates trust value
     * @param estimatedAgentID |
     *   identifies the agent whose trust is being estimated
     * @param lastState
     * @param action
     *
     * We assume that trust estimation changes only upon investee
     * returning part (if any) of the investment. The investment action
     * itself in assumed to not lead to trust changes.
     *
     * The idea behind the trust update itself is that trust increases
     * faster (in response to trustworthy actions) when it's low and
     * decreases faster (in response to untrustworthy actions) when
     * it's high.
     */
    let updateTrustEstimation = function(trust, estimatingAgentID, estimatedAgentID, state, observation) {
      let lastState = getPreviousState(state)
      let action = getLastAction(state)
      let maxPossibleTransfer = maxPossibleTransfer(lastState)
      /** no trust update if there was no choice for investee */
      if (maxPossibleTransfer == 0) return trust
      /** trust of action-taker doesn't change  */
      if (turn(lastState) === estimatedAgentID) return trust
      /** no trust update if action was an investment */
      if (turn(lastState) === 0) {
        /** after an investment, trust of investee changes depending on
         * how they responded to the last investment */
        // if this is the first time investing, no trust change
        if (lastState.returns.length === 0) {
          let transferProportion = action / maxPossibleTransfer
          return (transferProportion >= trust) ? Math.exp(trust-1) : Math.log(trust+1)
        }
        let lastReturn = lastState.returns[0]
        let lastInvestment = lastState.investments[0]
        if (lastInvestment == 0) return trust
        /** r1 measures how 'nice' investee was */
        let r1 = lastReturn / lastInvestment
        assert(r1 >= 0 && r1 <= 2, "updateTrustEstimation(): " +
          "r1=" + r1 + "; should be between 0 and 2!")
        /** r2 measures how 'nice' investor was */
        let r2 = action / lastInvestment
        assert(r2 >= 0 && r2 <= investorEndowment,
          "updateTrustEstimation(): r2=" + r2 + "; should be " +
          "between 0 and endowment!")

        let auxInfo = "\nr1=" + r1 + "; r2=" + r2

        /** trust will increase if investor is at least as nice as investee */
        if (r2 > 1 || r2 >= r1) {
          let factor = (r2 <= 1) ? 1 + 0.4*(1-r2) : 1 - (r2-1)/(investorEndowment-1)*0.3
          assert(factor >= 0.7 && factor <= 1.4,
            "updateTrustEstimation(): factor=" + factor +
            "; expected between 0.7 and 1.4!" + auxInfo)
          let result = Math.exp(factor * trust - factor)
          return result
        }
        /** otherwise, trust decreases */
        let factor = 0.3 + 0.4 * (r1-r2) / 2
        assert(factor >= 0.3 && factor <= 0.7,
          "updateTrustEstimation(): factor=" + factor +
        "; expected between 0.3 and 0.7")
        let result = Math.log((Math.exp(factor) - 1) * trust + 1)
        return result
      }

      let lastInvestment = lastState.investments[0]
      let expectedReturn = lastInvestment * 1.3
      if (action <= expectedReturn) {
        let result = action/lastInvestment * Math.exp(trust-1) +
               (1 - action/lastInvestment) * Math.log(trust+1)
        return result
      }
      assert(action - lastInvestment <= lastInvestment)
      let b = 1 - (action - lastInvestment) / lastInvestment
      let a = b/Math.E
      let c = b + Math.log(2-b)
      let auxInfo = "\na=" + a + ";b=" + b + ";c=" + c + ";trust=" +
        trust + ";action=" + action + ";lastInvestment=" + lastInvestment
      assert(0 <= a, "updateTrustEstimation(): unexpected value " +
        "of a: " + a + auxInfo)
      assert(a <= b, "updateTrustEstimation(): expected a < b, " +
        "found: a=" + a + ", b=" + b + auxInfo)
      assert( b <= c, "updateTrustEstimation(): expected b < c, " +
        "found: b=" + b + ", c=" + c + auxInfo)
      assert(c <= 1, "updateTrustEstimation(): unexpected " +
        "value of c: " + c + auxInfo)

      if (trust <= b) {
        let k = 1/b
        let l = Math.log(a)
        let result = Math.exp(k * trust + l)
        assert(result >= 0 && result <= 1, "updateTrustEstimation(): updated " +
          "trust=" + result + "; expected between 0 and 1;" + auxInfo)
        return result
      }
      let k = Math.exp(b)
      let l = Math.exp(b) * (1-b)
      let result = Math.log(k * trust + l)
      assert(result >= 0 && result <= 1, "updateTrustEstimation(): updated " +
        "trust=" + result + "; expected between 0 and 1;" + auxInfo)
      return result

      // let transferRatio = action / maxPossibleTransfer
      //
      // if (transferRatio > trust) {
      //   let trustIncreaseRatio = (transferRatio - trust) / (1 - trust)
      //   let lowRange = Math.log(trust) + 1
      //   let x = lowRange * (1 - trustIncreaseRatio) + trust * trustIncreaseRatio
      //   let result = Math.exp(x-1)
      //   assert(!_.isNaN(result) && result != undefined,
      //     "updateTrustValue returns " + result)
      //   return result
      // } else {
      //   let trustDecreaseRatio = (trust - transferRatio) / trust
      //   let hiRange = Math.exp(trust) - 1
      //   let x = hiRange * (1 - trustDecreaseRatio) + trust * trustDecreaseRatio
      //   let result = Math.log(x+1)
      //   assert(!_.isNaN(result) && result != undefined,
      //     "updateTrustValue returns " + result)
      //   return result
      // }
    }

    /** Compute agentID's trust toward the other agent */
    let computeTrust = function(agentID, belief, state) {
      let opponentID = otherAgentID(agentID)
      let individualBelief = retrieveBeliefOver(opponentID, belief)
      return goalCoeffExpectation(individualBelief, 1)
    }

    return {
      estimationHeuristicArr: [ updateTrustEstimation ],
      mentalStateArr: [ computeTrust ],
      mentalUtilities: [
        [[1]], /** agent 0 */
        [[0]]  /** agent 1 */
      ]
    }
  }()

  let initialState = {
    turn: 'investor',
    investments: [],
    returns: []
  }

  let params = {
    numberOfAgents: 2,
    numberOfRewards: {
      physical: 1,
      mental: 1
    }
  }

  let rewardUtilityFunctions = function() {
    let moneyUtility = function(x) {
      return x
    }

    let trustUtility = function(x) {
      return 8 * x
    }

    return [moneyUtility, trustUtility]
  }()

  return {
    actions,
    transitionFn,
    initialState,
    physicalRewardStructure,
    mentalStateDynamics,
    rewardUtilityFunctions,
    API,
    params
  }
}