# webppl-trust

WebPPL trust library. It provides means of creating *cognitive agents* 
operating in a *cognitive stochastic multiplayer game*. 

## Overview
The meat of the library is the ``src`` directory which contains 
following files:
* ``library.wppl`` implements the decision making process of cognitive 
agents
* ``auxiliary.wppl`` contains all the code that's not  

## Usage
To use the library, one must define all the components specific to 
the modeled scenario. In particular, this includes:
1. Game Setup, specifying the usual stuff such as states, actions, 
transition function as well as game API (described below) and other
novel components to do with rewards. Game setup should be specified
as a function which accepts game-specific parameters as input and
returns an object containing the following fields:
    * actions :: State -> [Action] <br/>
    a function that retrieves **actions** available to an agent
    in a given *state*
    * transitionFn :: (State, Action) -> State <br/>
    a function that gives a **state** to which the game transitions
    given that *action* was taken in a *state*
    * initialState :: State
    * API :: Object 
    specifies definitions of several functions which are used by the
    library but their implementations are game-specific, such as
        * getPreviousState :: State -> State <br/>
        given a *state*, returns a **state** that preceded *state* in
        the execution of the game. Normally states encode execution
        histories, so implementation of this function is trivial
        * getLastAction :: State -> Action
        * isInitial :: State
        * turn :: State -> Agent <br/>
        retrieves an **agent** that takes action in (owns) a given 
        *state* 
        * other :: Agent -> Agent <br/>
        given *agent* return the other **agent** (under assumption 
        there are only two agents)
        * stateToString :: State -> String
    * physicalRewardStructure :: Object 
    captures action and state rewards of agents. Must contain following 
    fields
        * stateRewards :: State -> [[Int]]
        Given a state, returns an array (indexed by agentID) whose ith
        element is an array of rewards obtained by agent i in that state.
        The length of this array of rewards should be equal to 
        params.numberOfRewards.physical (see below). 
        * actionRewards :: State -> [[Int]]
        As above, but returns rewards obtained from taking an action.
    * mentalStateDynamics :: Object
    captures the mental reward part of the utility function - that 
    involves providing estimation heuristic for each mental state
    as well as a way to compute each mental state. One must also 
    specify the mental component of each agent's utility function.
    Therefore, this object must contain the following fields:
        * estimationHeuristicArr :: [Function]
        array of functions expressing heuristics for each mental
        attitude. The length of the array should be equal to the 
        number of mental attitudes, i.e. equal to 
        params.numberOfRewards.mental. Each function should have
        the following signature: 
        Value -> AgentID -> State -> Action
        where Value=Int is the type of the value of the mental attitude
        * mentalStateArr :: [Function]
        as above, but this computes the mental state (from the 
        perspective of an agent). It captures how agents feel.
        * mentalUtilities :: [[[Int]]]
        captures mental utilities of each agent, indexed by agentID.
        Each element is an array indexed by mental attitudes (we assume
        they're ordered and indexed as 0,1,2,...) and the elements
        of that array are... arrays containing agentIDs, identifying
        agents whose mental state an agent cares about. It's easier
        to understand on an example. Take a game with two mental 
        attitudes (trust and guilt) and two agents (alice, bob).
        The order here matters, so trust is mental attitude index 0,
        guilt index 1, alice is agent with agentID=0, bob has ID 1.
        Then, the following mentalUtilities array
        [
        [[1],[0]], /** mental utility of agent 0 - alice */
        [[0,1],[1]], /** mental utility of agent 1 - bob */
        ]
        would reflect that 
        * alice cares about bob's trust ([1])
        * alice cares about her own guilt ([0])  
        * bob cares about alice's as well as his own trust ([0,1])
        * bob cares about his own guilt ([1])  
    * params :: Object
    must contain the following basic information about the game:
        * numberOfAgents :: Int
        * numberOfRewards :: Object, consisting of
            * physical :: Int
            * mental :: Int
     
