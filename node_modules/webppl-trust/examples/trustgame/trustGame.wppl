/**
Game structure
- we refer to the two players as *investor* and *investee*
- state consists of
  * turn: indicates whether next move is investing or returning
  * timeLeft: how many time steps are left in the game (-1 means infinite horizon)
  * investments: history of amounts sent by investor (most recent in position 0)
  * returns: history of amounts sent by investee (most recent in position 0)

  //* endowments: a dictionary {'investor': x, 'investee': y} specifying
    how much both players received in endowments in this stage

- we allow integer transfers not exceeding money available to player
- gameParams configure the game as follows:
  * investorEndowment: how much does investor get at the start of each round
  * investeeEndowment: how much does investee get at the start of each round
*/

/**
var params = {
  endowments : {
    'investor': 0,
    'investee': 0
  },
  k: 0,
  beliefRepresentation: <discrete/dirichlet>
}
*/
let makeTrustCSMG = function(gameSpecificParams) {
  let endowments = gameSpecificParams.endowments
  let investorEndowment = endowments.investor
  let k = gameSpecificParams.k
  let beliefRepresentation = gameSpecificParams.beliefRepresentation
  /**********************************
   *     Some auxiliary functions   *
   * ********************************/

  /** Compute endowment of agents in a state
   * @param state
   * @param params
   * @returns {investor: number, investee: number}
   */
  let endowment = function(state) {
    if (state.turn == "investor") {
      return endowments
    }
    return {
      investor: 0,
      investee: 0
    }
  }

  /** Computes the monetary transfer for each agent (positive or negative)
   * when *action* is taken in *state*
   * Params:
   *  - *state*
   *  - *action*
   * Returns
   *   an dictionary indexed by agent with money amount received (positive) or
   *   given away (negative)
   */
  let transfer = function(state, action) {
    let investor = action * ((state.turn == "investor") ? -1 : 1)
    return {
      'investor': investor,
      'investee': -investor
    }
  }

  /** Compute maximal possible amount that can be transferred from a given state */
  let maxPossibleTransfer = function(state) {
    return (state.turn == 'investor') ? investorEndowment :
      state.investments[0] * k
  }

  /** Game mechanics */
  let actions = function(state) {
    if (state.turn == 'investor') {
      return rangeArray(0, investorEndowment)
      // return [0,params.endowments.investor]
    }
    console.assert(state.investments.length > 0,
      "Investee turn, but no past investments recorded")
    return rangeArray(0, state.investments[0] * k)
  }

  let transitionFn = function(state, action) {
    info("transitionFn(state: " + stateToString(state) + ", action: " + action + ")")
    let turn = state.turn
    let nextTurn = (turn == 'investor') ? 'investee' : 'investor'
    let nextInvestments = (turn == 'investor') ?
      [action].concat(state.investments) : state.investments
    let nextReturns = (turn == 'investee') ?
      [action].concat(state.returns) : state.returns
    let result = {
      turn: nextTurn,
      investments: nextInvestments,
      returns: nextReturns
    }
    info("transitionFn(state: " + stateToString(state) + ", action: " + action + ")"
      + ": computed " + stateToString(result))
    return Delta({v: result})
  }

  /** Compulsory API of a game */
  let API = function() {
    let getPreviousState = function (state) {
      if (isInitial(state)) return state
      let prevTurn = (state.turn == 'investor') ? 'investee' : 'investor'
      // var prevTimeLeft = state.timeLeft + 1
      let prevInvestments = (prevTurn == 'investor') ? state.investments.slice(1) : state.investments
      let prevReturns = (prevTurn == 'investee') ? state.returns.slice(1) : state.returns
      return {
        turn: prevTurn,
        // timeLeft: prevTimeLeft,
        investments: prevInvestments,
        returns: prevReturns
      }
    }

    let getLastAction = function (state) {
      console.assert(!isInitial(state), "Calling previousAction on initial state")
      if (state.investments.length > state.returns.length)
        return state.investments[0]
      else
        return state.returns[0]
    }

    let isInitial = function (state) {
      return state.investments.length === 0 && state.returns.length === 0
    }

    let turn = function (state) {
      return state.turn
    }

    let stateToString = function (state) {
      return "{invs: " + arrayToString(state.investments) +
        ", rets: " + arrayToString(state.returns) + "}"
    }

    let API = {
      getPreviousState,
      getLastAction,
      isInitial,
      turn,
      stateToString
    }

    return API
  }()



  /** Physical rewards structure
   *  This is a relatively simple component which models state and
   *  action rewards that agents receive - these are the typical
   *  physical rewards familiar from other settings
   */
  let physicalRewardStructure = function() {

    /** State rewards
     *
     * @param state
     * @returns {{investor: array[reward], investee: array[reward]}}
     */
    let stateRewards = function(state) {
      let endowments = endowment(state)
      return {
        investor: [endowments.investor],
        investee: [endowments.investee]
      }
    }

    /** Action rewards
     *
     * @param state
     * @param action
     * @returns {{investor: array[number], investee: array[number]}}
     */
    let actionRewards = function(state, action) {
      let transfers = transfer(state, action)
      return {
        investor: [transfers.investor],
        investee: [transfers.investee]
      }
    }

    return {
      actionRewards,
      stateRewards,
    }
  }()

  /** Mental state dynamics model
   *  It consists of two components:
   *  (i) Heuristics agents use to estimate mental state of their opponents.
   *    This should be specified as an array of update functions, one for each
   *    mental state. Each update function has
   *    @type (mentalStateValue, agent, state, action) -> newMentalStateValue
   *  (ii) Mental state computation, i.e. how can actual mental state of an
   *    agent be computed. Each such function that computes some mental state
   *    of an agent has
   *    @type (state, belief) -> mentalStateValue
   */
  let mentalStateDynamics = function() {
    /** Update trust value of agent identified by @agentID upon
     *  @action taken in @state.
     *  The value is updated only if @state belongs to the other agent.
     *  Previous trust is given in @trust. This computation may be performed
     *  by either of agents.
     *
     * @param trust
     * @param agentID - (game-specific) identifier of an agent
     * @param state
     * @param action
     */
    let updateTrustEstimation = function(trust, agentID, state, action) {
      let maxPossibleTransfer = maxPossibleTransfer(state)
      // trust is only updated if other agent took action
      if (maxPossibleTransfer == 0 || state.turn == agentID) return trust
      let transferRatio = action / maxPossibleTransfer
      if (transferRatio > trust) {
        let trustIncreaseRatio = (transferRatio - trust) / (1 - trust)
        let lowRange = Math.log(trust) + 1
        let x = lowRange * (1 - trustIncreaseRatio) + trust * trustIncreaseRatio
        let result = Math.exp(x-1)
        assert(!_.isNaN(result) && result != undefined,
          "updateTrustValue returns " + result)
        return result
      } else {
        let trustDecreaseRatio = (trust - transferRatio) / trust
        let hiRange = Math.exp(trust) - 1
        let x = hiRange * (1 - trustDecreaseRatio) + trust * trustDecreaseRatio
        let result = Math.log(x+1)
        assert(!_.isNaN(result) && result != undefined,
          "updateTrustValue returns " + result)
        return result
      }
    }

    let computeTrust = function(state, belief) {
      return goalCoeffExpectation(belief, 1)
    }

    return {
      estimationHeuristicArr: [ updateTrustEstimation ],
      mentalStateArr: [ computeTrust ],
      mentalUtilities: [
        [[1]], /** agent 0 */
        [[0]]  /** agent 1 */
      ]
    }
  }()

  let initialState = {
    turn: 'investor',
    investments: [],
    returns: []
  }

  let params = {
    beliefRepresentation,
    numberOfAgents: 2,
    numberOfRewards: {
      physical: 1,
      mental: 1
    }
  }

  let rewardUtilityFunctions = function() {
    let moneyUtility = function(x) {
      return x
    }

    let trustUtility = function(x) {
      return 15 * x
    }

    return [moneyUtility, trustUtility]
  }()

  return {
    actions,
    transitionFn,
    initialState,
    physicalRewardStructure,
    mentalStateDynamics,
    rewardUtilityFunctions,
    API,
    params
  }
}