/**
 Game structure
 - we refer to the two players as *row* and *column*
 - state consists of
 * timeLeft: how many time steps are left in the game (-1 means infinite horizon)
 * history: list of past actions of players (tuples (rowAction, columnAction))
    (most recent in position 0)
 */

/**
 var params = {
  beliefRepresentation: <discrete/dirichlet>
}
 */

let player1 = "row"
let player2 = "column"

let makeBoobytrapCSMG = function() {

  /*******************
   * Game mechanics  *
   ***************** */

  /**  */

  /** returns vector of available actions for both players in a given state */
  let actions = function (state) {
    let actions = ["C", "D", "B"]
    return [actions, actions]
  }

  /** actions is a vector of actions taken by each player, eg ['C','B'] */
  let transitionFn = function (state, actions) {
    info("transitionFn(state: " + stateToString(state) + ", action: " + action + ")")
    let updatedHistory = [actions].concat(state.history)
    let result = {
      history: updatedHistory,
    }
    info("transitionFn(state: " + stateToString(state) + ", actions: " + actions + ")"
      + ": computed " + stateToString(result))
    return result
  }

  /** Compulsory API of a game */
  let API = function () {
    let getPreviousState = function (state) {
      if (isInitial(state)) return state
      let prevHistory = state.history.slice(1)
      return {
        history: prevHistory
      }
    }

    let getLastAction = function (state) {
      console.assert(!isInitial(state), "Calling getLastAction on initial state")
      return state.history[0]
    }

    let isInitial = function (state) {
      return state.history.length === 0
    }

    let turn = function (state) {
      return "both"
    }

    let other = function (player) {
      return (player == 'row') ? 'column' : 'row'
    }

    let stateToString = function (state) {
      return "{history: " + arrayToString(state.history) + "}"
    }

    let API = {
      getPreviousState,
      getLastAction,
      isInitial,
      turn,
      other,
      stateToString
    }

    return API
  }()

  /** Physical rewards structure
   *  This is a relatively simple component which models state and
   *  action rewards that agents receive - these are the typical
   *  physical rewards familiar from other settings
   */
  let physicalRewardStructure = function() {

    let actionToIndex = function(action) {
      let mapping = {C: 0, D: 1, B: 2}
      return mapping[action]
    }

    let payoffMatrix =
      [[[30,30],[10,40],[30,29]],
       [[40,10],[20,20],[-100,9]],
       [[29,30],[9,-100],[29,29]]]

    let stateRewards = function(state) {
      return [0,0]
    }

    let actionRewards = function(state, actions) {
      let row = actionToIndex(actions[0])
      let column = actionToIndex(actions[1])
      return payoffMatrix[row][column]
    }

    return {
      actionRewards,
      stateRewards,
      quantity: 1
    }
  }()

  /** Mental state dynamics model
   *  It consists of two components:
   *  (i) Heuristics agents use to estimate mental state of their opponents.
   *    This should be specified as an array of update functions, one for each
   *    mental state. Each update function has
   *    @type (mentalStateValue, agent, state, action) -> newMentalStateValue
   *  (ii) Mental state computation, i.e. how can actual mental state of an
   *    agent be computed. Each such function that computes some mental state
   *    of an agent has
   *    @type (state, belief) -> mentalStateValue
   */
  let getMentalStateDynamics = function(beliefAPI) {
    /** Update trust value of @agent upon @action taken in @state.
     *  The value is updated only if @state belongs to the other agent.
     *  Previous trust is given in @trust. This computation may be performed
     *  by either of agents.
     *
     * @param trust
     * @param agent - (game-specific) identifier of an agent
     * @param state
     * @param action
     */
    let updateTrustValue = function(trust, agent, state, action) {

    }

    let computeTrust = function(state, belief) {

    }

    return {
      estimationHeuristicArr: [ ],
      mentalStateArr: [ ]
    }
  }

  let initialState = {
    history: [],
  }

  let params = {
    beliefRepresentation: 'dirichlet',
    numberOfRewards: 1
  }

  let rewardUtilityFunctions = function() {
    let physicalUtility = function(x) {
      return x
    }
    return [physicalUtility]
  }()

  return {
    actions,
    transitionFn,
    initialState,
    physicalRewardStructure,
    getMentalStateDynamics,
    rewardUtilityFunctions,
    API,
    params
  }
}