/* Setup game structure */
let options = {
    tippingNorm: 20,
    gaspScores: [4,5],
    horizon: 4,
    beliefRepresentation: 'dirichlet'
}


let getScenarios = function() {
    /**
     basic scenario for now
     */
    let getScenario1 = function() {
        let name = "basic"
        let benParams = {
            goalCoeffs: [0.1, 0.9],
            metaParams: {
                alpha: 100,
                discountFactor: 0.8,
                lookAhead: 2
            }
        }
        let benInitialState = {
            belief: [2,2],
            mentalEstimations: [Delta({v: 0.7})], // an array of mental estimations (where each estimation is a distribution)
            metaParamsEstimations: {
                alpha: Categorical({vs: [100]}),
                lookAhead: Categorical({vs: [2]}),
                discountFactor: Categorical({vs: [0.8]})
            }
        }
        let abiParams = {
            goalCoeffs: [0.1, 0.9],
            metaParams: {
                alpha: 100,
                discountFactor: 0.8,
                lookAhead: 2
            }
        }
        let abiInitialState = {
            belief: [2,2],
            mentalEstimations: [Delta({v: 0.7})], // an array of mental estimations (where each estimation is a distribution)
            metaParamsEstimations: {
                alpha: Categorical({vs: [100]}),
                lookAhead: Categorical({vs: [2]}),
                discountFactor: Categorical({vs: [0.8]})
            }
        }
        return {name, benParams, benInitialState, abiParams, abiInitialState, options}
    }

    return [getScenario1()]
}

/**
 *
 * @param scenarios
 *  an array of dictionaries consisting of params, beliefs and estimations of both agents
 */
let simulateScenarios = function(scenarios) {
    if (scenarios.length == 0) return
    simulateScenario(scenarios[0])
    simulateScenarios(scenarios.slice(1))
}

let simulateScenario = function(scenario) {
    display(stringInABox("Scenario: " + scenario.name))
    display("Abi params:")
    display(scenario.abiParams)
    display("Abi initial state:")
    display(scenario.abiInitialState)
    display("Ben params:")
    display(scenario.benParams)
    display("Ben initial state:")
    display(scenario.benInitialState)
    let game = makeCSMG(makeTippingCSMG(scenario.options))
    let abi = makeAgent(scenario.abiParams, 1 , scenario.abiInitialState, game)
    let ben = makeAgent(scenario.benParams, 0, scenario.benInitialState, game)
    let players = [ ben, abi]
    let trajectory = simulate(game, players, scenario.options.horizon)
    display(trajectory)
}

// let computeTrust = function(agent, state, beliefAPI) {
//     // let beliefAPI = agent.beliefAPI
//     // let belief = beliefAPI.belief
//     let beliefFn = agent.belief
//     display(beliefFn(state))
//     let goalCoeffExp = beliefAPI.goalCoeffExpectation
//     return goalCoeffExp(beliefFn(state), 1)
// }
//
// let computeTrustEstimation = function(agent, state) {
//     let mentalRewards = agent.mentalRewards
//     return mentalRewards(state)[0]
// }

let computeGuilt = function(agent, state) {
    let mentalState = agent.mentalState
    return mentalState(state, 1, undefined)
}

/** Simulate execution */
let simulate = function(game, players, horizon, state) {
    display(players)
    display(state)
    let names = ['Ben', 'Abi']
    let abi = players[1]
    let ben = players[0]
    let beliefAPI = game.API.belief
    let turn = game.API.gameSpecific.turn
    let startingState = (state === undefined) ? game.initialState : state
    let trajectory = function(state, timeLeft, beliefAPI)  {
        if (timeLeft > 0) {
            let actingPlayer = players[turn(state)]
            display("New iteration. Time left: " + timeLeft + ", " + names[turn(state)] + " to act")
            let act = actingPlayer.act
            var start = _.now()
            var action = sample(act(state))
            let end = _.now()
            display("Action computed: " + action + ". Took " + (end - start) + " msec")
            let transitionFn = game.transitionFn
            let nextState = transitionFn(state, action)
            if (turn(nextState) == 0) {
                display("Abi's guilt for giving " + action + " tip: " + computeGuilt(abi, nextState))
            }

            // display("Updated trusts: { Alice: " + computeTrust(alice, nextState, beliefAPI) +
            //     ", Bob: " + computeTrust(bob, nextState, beliefAPI) + "}")
            // let mentalRewards = actingPlayer.mentalRewards
            // display("Updated trust estimations: { Alice (estimation of Bob's trust): " + computeTrustEstimation(alice, nextState) +
            //     ", Bob (estimation of Alice's trust): " + computeTrustEstimation(bob, nextState) + "}")
            // if (timeLeft == 1) {
            //   var aliceBelief = players['investor'].belief
            //   var bobBelief = players['investee'].belief
            //   display("final trust")
            //   display("Alice: " + aliceComputeTrust(aliceBelief(nextState)))
            //   display("Bob: " + bobComputeTrust(bobBelief(nextState)))
            // }
            return [[state, action]].concat(trajectory(nextState, timeLeft - 1, beliefAPI))
        }
        return []
    }
    // let horizon = game.params.horizon
    display("Simulation starts. Alice and Bob with " + horizon + " steps.")
    // display("Initial trusts: {Alice: " + computeTrust(alice, startingState, beliefAPI) +
    //     ", Bob: " + computeTrust(bob, startingState, beliefAPI) + "}")
    return trajectory(startingState, horizon, beliefAPI)
}

// let trajectory = simulate(trustCSMG, players)

// display(trajectory)
let scenarios = getScenarios()
// simulateScenarios(scenarios)
simulateScenario(scenarios[0])

// display(stringInABox("hello"))