/** This file contains all the belief operations.
 Belief can be represented in various ways and we want
 to be independent of particular representation. Therefore,
 an 'API' is given which defines what types of operations
 each representation should support (eg updating belief,
 retrieving belief etc) and those operations can then be
 invoked by clients without knowing the representation used.

 For each game, a belief structure must be obtained by
 providing all the necessary parameters (initial belief,
 representation) */

// let beliefAPI = function(game, agents, initialBeliefs, representation, numberOfRewards) {
//
//
//
//
//   /** REPRESENTATION DEPENDENT FUNCTIONS */
//   let discrete = function() {
//
//     let conditionalUtility = function(rewards, cond) {
//       info("conditionalUtility(rewards: " + arrayToString(rewards)
//         + ", " + condToString(cond) + ")")
//       return utilityFn(cond.goalCoeffs, rewards)
//     }
//
//
//     return {
//       conditionalUtility,
//     }
//   }()
//
//   let dirichlet = function() {
//     let conditionalUtility = function(rewards, cond) {
//       info("conditionalUtility(rewards: " + arrayToString(rewards)
//         + ", " + condToString(cond) + ")")
//       return rewards[cond.index]
//     }
//
//
//     return {
//       conditionalUtility,
//     }
//   }()
//
// }

/** PRIVATE */

let individualBeliefToString = function(individualBelief, numberOfGoalCoeffs) {
  assertDefined(individualBelief,
    "individualBeliefToString(): missing individualBelief")
  assertDefined(numberOfGoalCoeffs,
    "individualBeliefToString(): missing numberOfGoalCoeffs param")
  let toString = {
    'discrete': function() {
      let exps = goalCoeffsExpectation(individualBelief, numberOfGoalCoeffs)
      return arrayToString(exps)
    },
    'dirichlet': function() {
      /** value of belief is an array of dirichlet params */
      return arrayToString(individualBelief.value)
    }
  }[individualBelief.representation]
  return toString()
}

/** END PRIVATE */

/** belief is a dict { repr, value }, where value is an array
 * indexed by agents' ids. we re often interested in belief over
 * a particular agent which is what this function retrieves
 */
let retrieveBeliefOver = function(agentID, belief) {
  info("retrieveBeliefOver(): agentID=" + agentID + ", belief=" + toString(belief))
  let individualBelief = {
    representation: belief.representation,
    value: belief.value[agentID]
  }
  return individualBelief
}

let conditionalUtility = function(rewards, cond, utilityFn) {
  info("conditionalUtility(rewards: " + arrayToString(rewards)
    + ", " + condToString(cond) + ")")
  let appropriateFn = {
    'discrete': function(goalCoeffs) {
      return utilityFn(goalCoeffs, rewards)
    },
    'dirichlet': function(index) {
      return rewards[index]
    }
  }[cond.representation]
  return appropriateFn(cond.value)
}

/** individual belief */
let sampleBelief = function(individualBelief) {
  let appropriateFn = {
    'discrete' : function(beliefVal) {
      return sample(beliefVal)
    },
    'dirichlet': function(beliefVal) {
      /** this should not be called like this but for some reason,
       * calling sample(Dirichlet....) doesn't work */
      return Dirichlet({alpha: Vector(beliefVal)}).sample()
    }
  }[individualBelief.representation]
  return appropriateFn(individualBelief.value)
}

let goalCoeffExpectation = function(individualBelief, index) {
  // info("goalCoeffExpectation(): belief=" + toString(individualBelief) +
  //   ", index=" + index)
  let appropriateFn = {
    'discrete': function(beliefVal) {
      return expectation(marginalize(beliefVal, '' + index))
    },
    'dirichlet': function(beliefVal) {
      return beliefVal[index] / sum(beliefVal)
    }
  }[individualBelief.representation]
  let result = appropriateFn(individualBelief.value)
  // info("goalCoeffExpectation(): computed " + result + ", returning...")
  return result
}

let condToString = function (condition) {
  if (condition === undefined) return "undefined"
  let appropriateFn = {
    'discrete': function(goalCoeffs) {
      return "{ coeffs: " + arrayToString(goalCoeffs) + " }"
    },
    'dirichlet': function(index) {
      return "{ index: " + index + " }"
    }
  }[condition.representation]
  return appropriateFn(condition.value)
}

/** this expects FULL belief where value is array of distributions */
let beliefToString = function (fullBelief, numberOfGoalCoeffsArr) {
  aux("beliefToString(): fullBelief=" + toString(fullBelief) +
  ", numberOfGoalCoeffsArr=" + numberOfGoalCoeffsArr)
  let initialAcc = {
    'discrete': "Belief as expectations of each goalcoeff:",
    'dirichlet': "Belief as params to dirichlet dist"
  }[fullBelief.representation]
  let agentsNo = numberOfGoalCoeffsArr.length
  let agentsRange = rangeArray(0, agentsNo-1)
  let result = reduceL(function(acc, agentID) {
    let individualBelief = retrieveBeliefOver(agentID, fullBelief)
    let line = "\nOver agent " + agentID + ": " +
      individualBeliefToString(individualBelief,
        numberOfGoalCoeffsArr[agentID])
    return acc + line
  }, initialAcc, agentsRange)
  info("beliefToString(): returning")
  return result
}


/** this expects FULL belief where value is array of distributions */
let beliefToStringOLD = function (fullBelief, numberOfGoalCoeffsArr) {
  assertIsArray(fullBelief.value, OBJECT_TYPE)
  info("beliefToString(): belief:")
  info(fullBelief)
  info(arrayToString(fullBelief.value))
  let reductionFn = {
    'discrete': function(acc, agentID) {
        let individualBelief = retrieveBeliefOver(agentID, fullBelief)
        let exps =
          goalCoeffsExpectation(individualBelief, numberOfGoalCoeffsArr[agentID])
        let line = "\nOver agent " + agentID + ": " + arrayToString(exps)
        return acc + line
    },
    'dirichlet': function(acc, agentID) {
      let line = "\nOver agent " + agentID + ": " +
        arrayToString(fullBelief.value[agentID])
      return acc + line
    }
  }[fullBelief.representation]
  let initialAcc = {
    'discrete': "Belief as expectations of each goalcoeff:",
    'dirichlet': "Belief as params to dirichlet dist"
  }[fullBelief.representation]
  let agentsNo = fullBelief.value.length
  let agentsRange = rangeArray(0, agentsNo-1)
  let result = reduceL(reductionFn, initialAcc, agentsRange)
  info("beliefToString(): returning")
  return result
}

/** Takes individual belief as argument i.e. value is belief
 * over some agent.
 * returns array of expectations of goal coefficients */
let goalCoeffsExpectation = function (individualBelief, numberOfGoalCoeffs) {
  info("goalCoeffsExpectation(): belief= " + toString(individualBelief) +
    ", numberOfGoalCoeffs: " + numberOfGoalCoeffs)
  let result = map(function (index) {
      return goalCoeffExpectation(individualBelief, index)
    },
    rangeArray(0, numberOfGoalCoeffs - 1))
  info("goalCoeffsExpectation(): computed " + arrayToString(result))
  return result
}

