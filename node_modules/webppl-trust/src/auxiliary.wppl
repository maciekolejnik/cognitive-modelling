/** dependencies:
 * - assert
 */

/** returns an array [start, start+1,...,end] */
let rangeArray  = function(start,end,stepOptional) {
    assertDefined(start, "rangeArray(): start index undefined")
    assertDefined(end, "rangeArray(): end index undefined")
    let step = stepOptional || 1
    return (start > end) ? [] : [start].concat(rangeArray(start+step,end, step))
}

let arrayReplace = function (array, index, item) {
    assertIsArray(array, ANY_TYPE)
    assert(index >= 0 && index < array.length,
      "arrayReplace(): found index=" + index + " for array " + array)
    return mapIndexed(function(i, elem) {
        if (index == i) return item
        return elem
    }, array)
}

let arrayJoin = function(a1,a2) {
    return a1.concat(a2)
}

let arrayConcat = function(arrOfArrs) {
    return reduce(arrayJoin, [], arrOfArrs)
}

let arrayReverse = function(arr) {
    assertIsArray(arr, ANY_TYPE)
    return reduce(function(x, acc) {
        return acc.concat([x])
    }, [], arr)
}

let isEmpty = function(array) {
    assertIsArray(array, ANY_TYPE)
    return array.length === 0
}

/** This is a left fold (function @reduce provided by webppl is a right
 * fold). */
let reduceL = function(f, acc, arr) {
    assertIsArray(arr, ANY_TYPE)
    if (arr.length == 0) return acc
    return reduceL(f, f(acc, arr[0]), arr.slice(1))
}

let reduceL1 = function(f, arr) {
    assertIsArray(arr, ANY_TYPE)
    assert(arr.length > 0, "reduceL1(): input arr empty: " + arr)
    reduceL(f, arr[0], arr.slice(1))
}

let min = function(a,b) {
    return (a>b) ? b : a
}

let max = function(a,b) {
    return (a>b) ? a : b
}

/**
 * returns the most probable value in a support of a given distribution.
 * support must be passed separately as it is not accessible from the distribution object
 */
let mostProbableValueInSupport = function(dist, support) {
    let mostProbableValueInSupportHelper = function(dist, support, maxProbSoFar, valueWithMaxProb) {
        if (support.length == 0) return valueWithMaxProb
        let thisValue = support[0]
        let thisValueProb = Math.exp(dist.score(thisValue))
        let supportTail = support.slice(1)
        if (thisValueProb > maxProbSoFar) {
            return mostProbableValueInSupportHelper(dist, supportTail, thisValueProb, thisValue)
        }
        return mostProbableValueInSupportHelper(dist, supportTail, maxProbSoFar, valueWithMaxProb)
    }
    return mostProbableValueInSupportHelper(dist, support, 0, undefined)
}

let computeGoalCoeffsNumber = function(physicalRewardsNo, mentalUtilitiesArr) {
    let result = map(function(agentMentalUtils) {
        return physicalRewardsNo + arrayConcat(agentMentalUtils).length
    }, mentalUtilitiesArr)
    return result
}