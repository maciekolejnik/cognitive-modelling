/** This file contains a few functions useful for simulating
 * execution of games specified separately by defining getGameSetup.
 * It is expected that most users will want to define some scenarios,
 * each specifying initial setup of agents, and use 'simulateScenarios'
 * to simulate the unfolding of such scenario. */

/** Each scenario should contain the following elements:
 * - *name* of the scenario, possibly including a short description
 * - *agents* - array of agent parameters, specifying setup of each agent
 * - *gameSpecificParams* - parameters to be passed to getGameSetup
 * - *startingState*? - state from which to start simulation (optional)
 * - *options* - specifies simulation parameters such as
 *    - *horizon*
 *    - *beliefRepresentation*
 * */

/**
 *
 * @param scenarios
 * @param getGameSetup
 * @param namesOpt | optional but strongly recommended
 * @param callbacksOpt | (optional) object of the form
 * {
 *   setup: <function>,
 *   periodic: <function>>
 * }
 * containing functions to be called at the start and at each step
 * of executing each scenario. That allows some code, mainly in the form
 * of informational print statements, to be called as the game executes.
 */
let simulateScenarios = function (scenarios, getGameSetup, namesOpt, callbacksOpt) {
  if (scenarios.length == 0) return []
  let nextScenario = scenarios[0]
  let gameSetup = getGameSetup(nextScenario.gameSpecificParams)
  let names = namesOpt || rangeArray(0, gameSetup.params.numberOfAgents)
  let trajectory = simulateScenario(nextScenario, gameSetup, names, callbacksOpt)
  let otherTrajectories = simulateScenarios(
    scenarios.slice(1), getGameSetup, names, callbacksOpt)
  return [trajectory].concat(otherTrajectories)
}

/**
 * @param scenario has format
 * {
 * name: <name of scenario>,
 * options: <array of params to be passed to 'getGameSetup'>
 * agents: array of initial setups of agents of the form
 *   {
 *     params: {
         goalCoeffs: <array of goal coeffs>,
         metaParams: {
           alpha: <val>,
           discountFactor: <val>,
           lookAhead: <val>
         }
       }
     }
 * }
 */
let simulateScenario = function (scenario, gameSetup, names, callbacksOpt) {
  explain(stringInABox("Scenario: " + scenario.name))
  let agentsSetup = scenario.agents
  printAgentsSetup(agentsSetup, names)
  let game = makeCSMG(gameSetup, scenario.options)
  let agents = mapIndexed(function (i, agentSetup) {
    return makeAgent(agentSetup.params, i, agentSetup.initialState, game)
  }, agentsSetup)
  let trajectory = simulate(game, agents, scenario.options.horizon, names, callbacksOpt, scenario.startingState)
  explain("Scenario " + scenario.name + " computed trajectory: ")
  explain(arrayToString(trajectory))
  return trajectory
}


/** Simulate execution of *game* played by *agents* for *horizon*
 * steps. Additionally, optional arguments allow one to:
 * - specify a starting state other than initial state
 * - provide functions that will be called at the start
 * of simulation (callbacksOpt.setup) and at every iteration
 * (callbacksOpt.periodic)
 * - namesOpt
 *
 * @param game | instance of CSMG created by calling makeCSMG()
 * @param agents | array of agents, each created by calling makeAgent()
 * @param horizon | integer specifying number of steps
 * @param names | array of names of agents
 * @param callbacksOpt (optional) | functions to call during simulation
 * @param stateOpt (optional)
 * @returns an array of (state, action) pairs
 */
let simulate = function (game, agents, horizon, names, callbacksOpt, stateOpt) {
  let startingState = stateOpt || game.initialState
  explain("Simulation starts.")
  let stateToString = game.API.stateToString
  debug("startingState: " + stateToString(startingState))
  explain("Agents: " + arrayToString(names))
  if (callbacksOpt !== undefined && callbacksOpt.setup !== undefined) {
    callbacksOpt.setup(game, agents, startingState, names)
  }
  return trajectory(game, startingState, agents, horizon, names, callbacksOpt)
}

let trajectory = function (game, startingState, agents, timeLeft, names, callbacksOpt) {
  let trajectoryRec = function(state, timeLeft) {
    if (timeLeft > 0) {
      let turn = game.API.turn
      let actingPlayer = agents[turn(state)]
      explain("New iteration. Time left: " + timeLeft + ", " + names[turn(state)] + " to act")
      let act = actingPlayer.act
      let start = _.now()
      debug(state)
      let action = sample(act(state))
      let end = _.now()
      explain("Action computed: " + action + ". Took " + (end - start) + " msec")
      let transitionFn = game.transitionFn
      let nextState = sample(transitionFn(state, action))
      if (callbacksOpt !== undefined && callbacksOpt.periodic !== undefined) {
        callbacksOpt.periodic(game, agents, state, names)
      }
      return [[state, action]].concat(trajectoryRec(nextState,timeLeft - 1))
    }
    return []
  }
  trajectoryRec(startingState, timeLeft)
}

let printAgentsSetup = function (agents, names) {
  assertEqual(agents.length, names.length,
    "printAgents(): expecting names for all agents and no more")
  if (agents.length === 0) return
  explain("Agent: " + names[0])
  explain("Params: ")
  explain(agents[0].params)
  explain("Initial state: ")
  explain(agents[0].initialState)
  explain("-----------------------------------------")
  printAgentsSetup(agents.slice(1), names.slice(1))
}