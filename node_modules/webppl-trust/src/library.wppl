/* Auxiliary functions */
var stateToString = function(state) {
  var turn = "Turn: " + state.turn + "\n"
  var time = "Time left: " + state.timeLeft + "\n"
  var investments = "Past investments: " + state.investments + "\n"
  var returns = "Past returns: " + state.returns
  return turn + time + investments + returns
}

var other = function(player) {
  return (player == 'investor') ? 'investee' : 'investor'
}

// returns an array [start, start+1,...,end]
var rangeArray = function(start,step,end) {
  return (start > end) ? [] : [start].concat(rangeArray(start+step,step,end))
}

// computes endowment for an agent with *role* in a given
// *state*. This is either 0 or whatever is defined in game params
var endowment = function(state, role, params) {
  // return state.endowments[role]
  if (state.turn == "investor") {
    return params.endowments[role]
  }
  return 0
}

var transfer = function(state, action, role) {
  return action * ((state.turn == role) ? -1 : 1)
}

var trust = function(params) {
  return params.trustWeight / (params.moneyWeight + params.trustWeight)
}

var trustExp = function(belief) {
  return expectation(Infer({method: 'forward'}, function() {
    return trust(sample(belief))
    // var params = {
    //   moneyWeight: sample(belief).moneyWeight,
    //   trustWeight: sample(belief).trustWeight
    // }
    // return trust(params)
  }))
}
/* 
Game structure 
- we refer to the two players as *investor* and *investee*
- state consists of
  //* investorMoney: investor's money amount
  //* investeeMoney: investee's money amount
  * turn: indicates whether next move is investing or returning
  * timeLeft: how many time steps are left in the game 
  * investments: history of amounts sent by investor
  * returns: history of amounts sent by investee

  * endowments: a dictionary {'investor': x, 'investee': y} specifying
    how much both players received in endowments in this stage

- we allow integer transfers not exceeding money available to player
- gameParams configure the game as follows:
  * investorEndowment: how much does investor get at the start of each round
  * investeeEndowment: how much does investee get at the start of each round
*/

/*
var params = {
  endowments : {
    'investor': 0,
    'investee': 0
  },
  k: 0,
  horizon: 0
}
*/

var makeTrustCSMG = function(params) {
  var actions = function(state) {
    if (state.turn == 'investor') {
      return rangeArray(0, 1, params.endowments.investor)
    }
    console.assert(state.investments.length > 0, 
      "Investee turn, but no past investments recorded")
    return rangeArray(0, params.k, state.investments[0] * params.k)
  }

  var transition = function(state, action) {
    var turn = state.turn
    var timeLeft = state.timeLeft
    // var endowments = state.endowments
    var nextTimeLeft = state.timeLeft - 1
    var nextTurn = (turn == 'investor') ? 'investee' : 'investor'
    var nextInvestments = (turn == 'investor') ? [action].concat(state.investments) : state.investments
    var nextReturns = (turn == 'investee') ? [action].concat(state.returns) : state.returns
    // var nextEndowments = {
    //   investor: (endowments.investor == 0) ? params.endowments.investor : 0,
    //   investee: (endowments.investee == 0) ? params.endowments.investee : 0
    // }
    return {
      turn: nextTurn,
      timeLeft: nextTimeLeft,
      investments: nextInvestments,
      returns: nextReturns
      // ,endowments: nextEndowments
    }
  }

  var initialState = {
    turn: 'investor',
    timeLeft: params.horizon,
    investments: [],
    returns: []
    // ,
    // endowments: params.endowments
  }

  return {
    actions,
    transition,
    initialState,
    // endowment,
    params
  }
}

/* Cognitive trust aware agent */

/*
selfParams = {
 alpha: [0,inf),
 moneyWeight: [0,1],
 trustWeight:  [0,1],
 role: 'investor'/'investee'
 initialBelief: {
  alpha: <dist>,
  moneyWeight: <dist>,
  trustWeight: <dist>
 }
}
*/
var makeAgent = function(selfParams, game) {

  var updateBelief = function(belief, state, action, timeLeft) {
    // don't update belief if it was agent's own action
    if (selfParams.role == state.turn) {
      return belief
    }
    var dist = Infer({method: 'enumerate'}, function() {
      var params = sample(belief)
      var predictedAction = sample(act(state, timeLeft, belief, params))
      condition(predictedAction == action)
      return params
    })
    return dist
  }

  // a given agent needs to be able to compute their own, as well
  // as their opponent's utility (for the opponent, it's computed
  // as an expectation)
  var utility = function(state, action, belief, role, otherParams) {
    var utilityFn = function(params, income, trust) {
      return params.moneyWeight * income + params.trustWeight * trust
    }
    // first compute income for this stage
    var transfer = transfer(state, action, role)
    var endowment = endowment(state, role, game.params)
    var income = transfer + endowment
    
    var params = (role == selfParams.role) ? selfParams : otherParams
    // now compute trust at this stage
    // agent's own trust is just expectation of opponent's trustwortiness
    // agent's estimation of opponent's expectation of agent's trust is
    // currently, for simplicity, agent's actual value of trust
    // display(belief)
    var trust = (role == selfParams.role) ? trustExp(belief) : trust(selfParams)
    if (params !== undefined) {
      return utilityFn(params, income, trust)
    }
    console.assert(role != selfParams.role, "About to compute own utility as exp")
    return expectation(Infer({ method: 'forward'}, function() {
      var params = sample(belief)
      return utilityFn(params, income, trust)
    }))
  }

  // *otherParams* is an optional argument which specifies parameters
  // of the opponent
  var act = function(state, timeLeft, belief, otherParams) {
    // display("in act() for " + selfParams.role + ", timeLeft: " + timeLeft)
    var alpha = (state.turn == selfParams.role) ? selfParams.alpha : 
      ((otherParams === undefined) ? expectation(marginalize(belief, 'alpha')) : otherParams.alpha)
    var dist = Infer({method: 'enumerate'}, function() {
      var actions = game.actions
      var action = uniformDraw(actions(state))
      var eu = expectedUtility(state, action, state.turn, timeLeft, belief, otherParams)
      factor(alpha * eu)
      return action
    })
    return dist
  }

  var expectedUtility = function(state, action, role, timeLeft, belief, otherParams) {
    // display("expectedUtility for action " + action + ", role: " + role + ", time: " + timeLeft)
    var start = _.now()
    var u = utility(state, action, belief, role, otherParams)
    var nextTimeLeft = timeLeft - 1
    if (nextTimeLeft == 0) {
      // display("[" + action + "," + timeLeft + "," + role + "," + state.investments + 
      //   "," + state.returns + "]. Took " + (_.now() - start))
      return u
    }
    var eu = u + expectation(Infer({method: 'enumerate'}, function() {
      // for now, we don't update belief
      // var nextBelief = updateBelief(belief, state, action, timeLeft)
      var nextBelief = belief
      var transition = game.transition
      var nextState = transition(state, action)
      var nextAction = sample(act(nextState, nextTimeLeft, nextBelief, otherParams))
      return expectedUtility(nextState, nextAction, role, nextTimeLeft, nextBelief, otherParams) 
    }))
    if (timeLeft == 6 && otherParams === undefined) {
      display("[" + action + "," + timeLeft + "," + role + "," + state.investments + 
        "," + state.returns + "]. Took " + (_.now() - start) + ". EU=" + eu) 
    }
    return eu   
  }
  return { params: selfParams, act, expectedUtility, updateBelief}
}