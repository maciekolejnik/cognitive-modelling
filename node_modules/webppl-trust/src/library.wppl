/* Auxiliary functions */
var stateToString = function(state) {
  var turn = "Turn: " + state.turn + "\n"
  var time = "Time left: " + state.timeLeft + "\n"
  var investments = "Past investments: " + state.investments + "\n"
  var returns = "Past returns: " + state.returns
  return turn + time + investments + returns
}

var other = function(player) {
  return (player == 'investor') ? 'investee' : 'investor'
}

// returns an array [start, start+1,...,end]
var rangeArray = function(start,step,end) {
  return (start > end) ? [] : [start].concat(rangeArray(start+step,step,end))
}

// computes endowment for an agent with *role* in a given
// *state*. This is either 0 or whatever is defined in game params
var endowment = function(state, role, params) {
  // return state.endowments[role]
  if (state.turn == "investor") {
    return params.endowments[role]
  }
  return 0
}

var transfer = function(state, action, role) {
  return action * ((state.turn == role) ? -1 : 1)
}

var trustVal = function(params) {
  return params.trustWeight / (params.moneyWeight + params.trustWeight)
}

var trustExp = function(belief) {
  return expectation(Infer({method: 'forward', samples: 50}, function() {
    return trustVal(sample(belief))
  }))
}
/* 
Game structure 
- we refer to the two players as *investor* and *investee*
- state consists of
  //* investorMoney: investor's money amount
  //* investeeMoney: investee's money amount
  * turn: indicates whether next move is investing or returning
  * timeLeft: how many time steps are left in the game 
  * investments: history of amounts sent by investor
  * returns: history of amounts sent by investee

  * endowments: a dictionary {'investor': x, 'investee': y} specifying
    how much both players received in endowments in this stage

- we allow integer transfers not exceeding money available to player
- gameParams configure the game as follows:
  * investorEndowment: how much does investor get at the start of each round
  * investeeEndowment: how much does investee get at the start of each round
*/

/*
var params = {
  endowments : {
    'investor': 0,
    'investee': 0
  },
  k: 0,
  horizon: 0
}
*/

var makeTrustCSMG = function(params) {
  var actions = function(state) {
    if (state.turn == 'investor') {
      return rangeArray(0, 1, params.endowments.investor)
    }
    console.assert(state.investments.length > 0, 
      "Investee turn, but no past investments recorded")
    return rangeArray(0, 1, state.investments[0] * params.k)
  }

  var transition = function(state, action) {
    var turn = state.turn
    var timeLeft = state.timeLeft
    var nextTimeLeft = state.timeLeft - 1
    var nextTurn = (turn == 'investor') ? 'investee' : 'investor'
    var nextInvestments = (turn == 'investor') ? [action].concat(state.investments) : state.investments
    var nextReturns = (turn == 'investee') ? [action].concat(state.returns) : state.returns
    return {
      turn: nextTurn,
      timeLeft: nextTimeLeft,
      investments: nextInvestments,
      returns: nextReturns
    }
  }

  var initialState = {
    turn: 'investor',
    timeLeft: params.horizon,
    investments: [],
    returns: []
    // ,
    // endowments: params.endowments
  }

  return {
    actions,
    transition,
    initialState,
    // endowment,
    params
  }
}

/* Cognitive trust aware agent */

/*
selfParams = {
 alpha: [0,inf),
 moneyWeight: [0,1],
 trustWeight:  [0,1]
}
*/
var makeAgent = function(selfParams, agentRole, trustBeliefs, game) {

  var updateBelief = function(belief, state, action, timeLeft) {
    // don't update belief if it was agent's own action
    if (agentRole == state.turn) {
      return belief
    }
    var dist = Infer({method: 'enumerate'}, function() {
      var params = sample(belief)
      var predictedAction = sample(act(state, timeLeft, belief, params))
      condition(predictedAction == action)
      return params
    })
    return dist
  }

  /* Trust dynamics */
  var trust = dp.cache(function(state, action) {
    // display("compute trust for state")
    // display(state)
    var isInitial = function(state) {
      return state.investments.length === 0 && state.returns.length === 0
    }
    var previousState = function(state) {
      var prevTurn = (state.turn == 'investor') ? 'investee' : 'investor'
      var prevTimeLeft = state.timeLeft + 1
      var prevInvestments = (prevTurn == 'investor') ? state.investments.slice(1) : state.investments
      var prevReturns = (prevTurn == 'investee') ? state.returns.slice(1) : state.returns
      return {
        turn: prevTurn,
        timeLeft: prevTimeLeft,
        investments: prevInvestments,
        returns: prevReturns
      }
    }
    var previousAction = function(state) {
      if (state.investments.length > state.returns.length) {
        return state.investments[0]
      } else {
        return state.returns[0]
      }
    }
    var updateTrustBelief = function(trustBelief, transfer, maxPossibleTransfer) {
      console.assert(transfer <= maxPossibleTransfer, 
        "Transfer exceeded max possible transfer: " + transfer + ", " + maxPossibleTransfer)
      if (maxPossibleTransfer == 0) {
        return trustBelief
      }
      return Infer({ method: 'enumerate' }, function() {
        var trust = sample(trustBelief)
        var transferRatio = transfer / maxPossibleTransfer
        var newTrust = (transferRatio > trust) ? Math.exp(trust-1) : Math.log(trust+1)
        var absDiff = Math.abs(trust - newTrust)
        return (transferRatio > trust) ? 
          trust + absDiff * transferRatio : 
          trust - absDiff * (1 - transferRatio)  
      })
    }
    var prevTrustBeliefs = (isInitial(state)) ? trustBeliefs : 
      trust(previousState(state), previousAction(state))

    // if (isInitial(state)) {
    //   return trustBeliefs
    // }
    // var lastInvestment = state.investments[0]
    // var lastReturn = state.returns[0]
    // var prevState = previousState(state)
    // var prevTrust = trust(prevState)
    var investorTrust = (state.turn == 'investor') ? 
      prevTrustBeliefs.investor : 
      updateTrustBelief(prevTrustBeliefs.investor, action, state.investments[0] * game.params.k)
    var investeeTrust = (state.turn == 'investee') ? prevTrustBeliefs.investee :
      updateTrustBelief(prevTrustBeliefs.investee, action, game.params.endowments.investor)
    return {
      investor: investorTrust,
      investee: investeeTrust
    }
  })

  // a given agent needs to be able to compute their own, as well
  // as their opponent's utility (for the opponent, it's computed
  // as an expectation)
  var utility = function(state, action, belief, role, otherParams) {
    var utilityFn = function(params, income, trust) {
      // display("Income: " + income + ", trust: " + trust)
      return params.moneyWeight * income + params.trustWeight * trust
    }
    // first compute income for this stage
    var transfer = transfer(state, action, role)
    var endowment = endowment(state, role, game.params)
    var income = transfer + endowment
    // display("Role: " + role + ", income: " + income)
    var maxPossibleIncome = (state.turn == 'investee') ? 
      ((role == 'investee') ? game.params.k * state.investments[0] : game.params.k * state.investments[0]):
      ((role == 'investor') ? endowment : endowment + game.params.k * game.params.endowments.investor)
    console.assert(Math.abs(income) <= Math.abs(maxPossibleIncome), "Income is bigger than calculated max possible income")
    var incomeRatio = (maxPossibleIncome != 0) ? income / maxPossibleIncome : 0
    console.assert(incomeRatio >= -1 && incomeRatio <= 1, "incomeRatio out of bounds: " + incomeRatio)
    
    var params = (role == agentRole) ? selfParams : otherParams
    // now compute trust at this stage
    // agent's own trust is just expectation of opponent's trustwortiness
    // agent's estimation of opponent's expectation of agent's trust is
    // currently, for simplicity, agent's actual value of trust
    // display(belief)
    // var trust = (role == agentRole) ? trustExp(belief) : trustVal(selfParams)
    var trust = expectation(trust(state, action)[other(role)])
    // display("trust of " + other(role) + ": " + trust)
    if (params !== undefined) {
      // return utilityFn(params, incomeRatio, trust)
      return utilityFn(params, income, trust)
    }
    console.assert(role != agentRole, "About to compute own utility as exp")
    return expectation(Infer({ method: 'enumerate'}, function() {
      var params = sample(belief)
      // return utilityFn(params, incomeRatio, trust)
      return utilityFn(params, income, trust)
    }))
  }

  // *otherParams* is an optional argument which specifies parameters
  // of the opponent
  // topLevel is an optional parameter that helps with printing debug messages
  // it's meant to be set to true when act is called form the top level
  var act = function(state, timeLeft, belief, otherParams, topLevel) {
    // display("in act() for " + agentRole + ", timeLeft: " + timeLeft)
    var alpha = (state.turn == agentRole) ? selfParams.alpha : 
      ((otherParams === undefined) ? expectation(marginalize(belief, 'alpha')) : otherParams.alpha)
    var dist = Infer({method: 'enumerate'}, function() {
      var actions = game.actions
      var action = uniformDraw(actions(state))
      var eu = expectedUtility(state, action, state.turn, timeLeft, belief, otherParams, topLevel)
      factor(alpha * eu)
      return action
    })
    // if (timeLeft == 1) {
    //   display(dist)
    // }
    return dist
  }

  var expectedUtility = function(state, action, role, timeLeft, belief, otherParams, topLevel) {
    // display("expectedUtility for action " + action + ", role: " + role + ", time: " + timeLeft)
    var start = _.now()
    var u = utility(state, action, belief, role, otherParams)
    // if (timeLeft == 1) {
    //   display("[" + action + "," + timeLeft + "," + role + "," + state.investments + 
    //     "," + state.returns + "]. Took " + (_.now() - start) + ". U=" + u)
    // }
    var nextTimeLeft = timeLeft - 1
    if (nextTimeLeft == 0) {
      // display("[" + action + "," + timeLeft + "," + role + "," + state.investments + 
      //   "," + state.returns + "]. Took " + (_.now() - start))
      return u
    }
    // var nextBelief = updateBelief(belief, state, action, timeLeft)
    var nextBelief = belief
    var transition = game.transition
    var nextState = transition(state, action)  
    var eu = u + expectation(Infer({method: 'enumerate'}, function() {
      // for now, we don't update belief
      var nextAction = sample(act(nextState, nextTimeLeft, nextBelief, otherParams))
      return expectedUtility(nextState, nextAction, role, nextTimeLeft, nextBelief, otherParams) 
    }))
    if (topLevel) {
      display("[" + action + "," + timeLeft + "," + role + "," + state.investments + 
        "," + state.returns + "]. Took " + (_.now() - start) + ". EU=" + eu)
      display("Trusts at the next state.")
      // var nextState = transition(state, action)
      display("Investor: " + expectation(trust(state, action).investor))
      display("Investee: " + expectation(trust(state, action).investee))
    }
    return eu   
  }
  return { params: selfParams, act, expectedUtility, updateBelief}
}