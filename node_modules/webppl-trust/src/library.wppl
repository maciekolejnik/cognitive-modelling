/* Auxiliary functions */
var stateToString = function(state) {
  var turn = "Turn: " + state.turn + "\n"
  var time = "Time left: " + state.timeLeft + "\n"
  var investments = "Past investments: " + state.investments + "\n"
  var returns = "Past returns: " + state.returns
  return turn + time + investments + returns
}

var stateToStringShort = function(state) {
  return "[" + state.timeLeft + ",[" + state.investments + "],[" + state.returns + "]]"
}

var other = function(player) {
  return (player == 'investor') ? 'investee' : 'investor'
}

// returns an array [start, start+1,...,end]
var rangeArray = function(start,step,end) {
  return (start > end) ? [] : [start].concat(rangeArray(start+step,step,end))
}

// computes endowment for an agent with *role* in a given
// *state*. This is either 0 or whatever is defined in game params
var endowment = function(state, role, params) {
  // return state.endowments[role]
  if (state.turn == "investor") {
    return params.endowments[role]
  }
  return 0
}

var transfer = function(state, action, role) {
  return action * ((state.turn == role) ? -1 : 1)
}

var maxPossibleIncome = function(state, role, gameParams) {
  var k = gameParams.k
  var investorEndowment = gameParams.endowments.investor
  var investeeEndowment = gameParams.endowments.investee
  if (state.turn == 'investee') { 
    return k * state.investments[0] 
  }
  // state.turn == investor
  if (role == 'investor') {
    return investorEndowment
  } else {
    return investeeEndowment + k * investorEndowment
  }
}

var trustVal = function(params) {
  return params.trustWeight / (params.moneyWeight + params.trustWeight)
}

var trustExp = function(belief) {
  return expectation(Infer({method: 'forward', samples: 50}, function() {
    return trustVal(sample(belief))
  }))
}
var isInitial = function(state) {
  return state.investments.length === 0 && state.returns.length === 0
}
var previousState = function(state) {
  var prevTurn = (state.turn == 'investor') ? 'investee' : 'investor'
  var prevTimeLeft = state.timeLeft + 1
  var prevInvestments = (prevTurn == 'investor') ? state.investments.slice(1) : state.investments
  var prevReturns = (prevTurn == 'investee') ? state.returns.slice(1) : state.returns
  return {
    turn: prevTurn,
    timeLeft: prevTimeLeft,
    investments: prevInvestments,
    returns: prevReturns
  }
}
var previousAction = function(state) {
  if (state.investments.length > state.returns.length) {
    return state.investments[0]
  } else {
    return state.returns[0]
  }
}

/** Logging 
  * levels 0-5
  * 0 is no logging
  * 1 only log critical (critical)
  * 4 is log all but info (critical, debug)
  * 5 is log everything (critical, debug, info)
*/

var getLogger = function(level) {
  var info = function(message) {
    if (level >= 5) {
      display(message)
    }
  }

  var debug = function(message) {
    if (level >= 4) {
      display(message)
    }
  }

  var critical = function(message) {
    if (level >= 1) {
      display(message)
    }
  }

  return {info, debug, critical}
}
var logger = getLogger(1)
var debug = logger.debug
var info = logger.info
var critical = logger.critical
/* 
Game structure 
- we refer to the two players as *investor* and *investee*
- state consists of
  //* investorMoney: investor's money amount
  //* investeeMoney: investee's money amount
  * turn: indicates whether next move is investing or returning
  * timeLeft: how many time steps are left in the game 
  * investments: history of amounts sent by investor
  * returns: history of amounts sent by investee

  * endowments: a dictionary {'investor': x, 'investee': y} specifying
    how much both players received in endowments in this stage

- we allow integer transfers not exceeding money available to player
- gameParams configure the game as follows:
  * investorEndowment: how much does investor get at the start of each round
  * investeeEndowment: how much does investee get at the start of each round
*/

/*
var params = {
  endowments : {
    'investor': 0,
    'investee': 0
  },
  k: 0,
  horizon: 0
}
*/

var makeTrustCSMG = function(params) {
  var actions = function(state) {
    if (state.turn == 'investor') {
      return rangeArray(0, 1, params.endowments.investor)
    }
    console.assert(state.investments.length > 0, 
      "Investee turn, but no past investments recorded")
    return rangeArray(0, 1, state.investments[0] * params.k)
  }

  var transition = function(state, action) {
    var turn = state.turn
    var timeLeft = state.timeLeft
    var nextTimeLeft = state.timeLeft - 1
    var nextTurn = (turn == 'investor') ? 'investee' : 'investor'
    var nextInvestments = (turn == 'investor') ? [action].concat(state.investments) : state.investments
    var nextReturns = (turn == 'investee') ? [action].concat(state.returns) : state.returns
    return {
      turn: nextTurn,
      timeLeft: nextTimeLeft,
      investments: nextInvestments,
      returns: nextReturns
    }
  }

  var initialState = {
    turn: 'investor',
    timeLeft: params.horizon,
    investments: [],
    returns: []
  }

  return {
    actions,
    transition,
    initialState,
    params
  }
}

/* Cognitive trust aware agent */

/*
selfParams = {
 alpha: [0,inf),
 lookAhead: [0,inf) (integer),
 discountFactor: (0,1],
 moneyWeight: [0,1],
 trustWeight:  [0,1]
}
*/
var makeAgent = function(selfParams, selfRole, trustBeliefs, initialBelief, game) {

  /* Some functions for easier access */
  var transition = game.transition

  /** Belief update
    * Computes agent's belief in *state*. Proceeds recursively.
  */
  var belief = dp.cache(function(state) {
    debug("belief(" + stateToStringShort(state) + ") for " + selfRole)
    var updateBelief = function(belief, state, action) {
      // don't update belief if it was agent's own action
      debug("updateBelief(belief, " + stateToStringShort(state) + ", " + action + ")")
      if (selfRole == state.turn) {
        return belief
      }
      var dist = Infer({method: 'enumerate'}, function() {
        var params = sample(belief)
        var predictedAction = sample(act(state, params))
        condition(predictedAction == action)
        return params
      })
      return dist
    }
    if (isInitial(state)) {
      return initialBelief
    }
    var prevState = previousState(state)
    var prevAction = previousAction(state)
    var prevBelief = belief(prevState)
    debug("belief(" + stateToStringShort(state) + ") for " + selfRole + ". COMPLETED")
    return updateBelief(prevBelief, prevState, prevAction)
  })

  /** Trust dynamics 
    * This function updates trust beliefs upon *action* being taken in *state*.
    * Trust is updated for the agent who did not perform the action.
  */
  var trust = dp.cache(function(state, action) {
    var updateTrustBelief = function(trustBelief, transfer, maxPossibleTransfer) {
      console.assert(transfer <= maxPossibleTransfer, 
        "Transfer exceeded max possible transfer: " + transfer + ", " + maxPossibleTransfer)
      if (maxPossibleTransfer == 0) {
        return trustBelief
      }
      return Infer({ method: 'enumerate' }, function() {
        var trust = sample(trustBelief)
        var transferRatio = transfer / maxPossibleTransfer
        var newTrust = (transferRatio > trust) ? Math.exp(trust-1) : Math.log(trust+1)
        var absDiff = Math.abs(trust - newTrust)
        return (transferRatio > trust) ? 
          trust + absDiff * transferRatio : 
          trust - absDiff * (1 - transferRatio)  
      })
    }
    var prevTrustBeliefs = (isInitial(state)) ? trustBeliefs : 
      trust(previousState(state), previousAction(state))
    var investorTrust = (state.turn == 'investor') ? 
      prevTrustBeliefs.investor : 
      updateTrustBelief(prevTrustBeliefs.investor, action, state.investments[0] * game.params.k)
    var investeeTrust = (state.turn == 'investee') ? prevTrustBeliefs.investee :
      updateTrustBelief(prevTrustBeliefs.investee, action, game.params.endowments.investor)
    return {
      investor: investorTrust,
      investee: investeeTrust
    }
  })

  /** Utility function 
    * Compute utility for *role* when *action* is performed (by whoever) in *state*.
    * This is achieved by computing income as a sum of endowment and transfer (can be negative)
    * and trust value using trust dynamics.
  */
  var utility = dp.cache(function(state, action, role, otherParams) {
    var utilityFn = function(params, income, trust) {
      return params.moneyWeight * income + params.trustWeight * trust
    }
    // first compute income for this stage
    var transfer = transfer(state, action, role)
    var endowment = endowment(state, role, game.params)
    var income = transfer + endowment
    var maxPossibleIncome = maxPossibleIncome(state, role, game.params)
    // var maxPossibleIncome = (state.turn == 'investee') ? game.params.k * state.investments[0] :
    //   ((role == 'investor') ? endowment : endowment + game.params.k * game.params.endowments.investor)
    console.assert(Math.abs(income) <= Math.abs(maxPossibleIncome), "Income is bigger than calculated max possible income")
    var incomeRatio = (maxPossibleIncome != 0) ? income / maxPossibleIncome : 0
    console.assert(incomeRatio >= -1 && incomeRatio <= 1, "incomeRatio out of bounds: " + incomeRatio)
    
    // now compute trust at this stage using trust dynamics
    var trust = expectation(trust(state, action)[other(role)])

    var params = (role == selfRole) ? selfParams : otherParams
    if (params !== undefined) {
      return utilityFn(params, incomeRatio, trust)
      // return utilityFn(params, income, trust)
    }
    console.assert(role != selfRole, "About to compute own utility as exp")
    var belief = belief(transition(state, action))
    return expectation(Infer({ method: 'enumerate'}, function() {
      var params = sample(belief)
      return utilityFn(params, incomeRatio, trust)
      // return utilityFn(params, income, trust)
    }))
  })

  /** Compute action (distribution) at state
    * It is a recursive procedure, where depth of the recursion is determined by
    * the *lookAhead* paramater of the agent that performs action in the given *state*.
    * Currently, when act is called with a state where the other agent performs aciton,
    * *otherParams* must be passed. 
  */
  var act = dp.cache(function(state, otherParams) {
    var start = _.now()
    debug("act(" + stateToStringShort(state) + ", " + otherParams + ")")
    // display(state.turn == selfRole || otherParams !== undefined)
    console.assert(state.turn == selfRole || otherParams !== undefined, "Invalid input to act()")
    var lookAhead = (state.turn == selfRole) ? selfParams.lookAhead : otherParams.lookAhead
    var result = actRec(state, lookAhead, otherParams, true && otherParams === undefined)
    debug("act finished in " + (_.now() - start) + " msec.")
    return result
  })

  var actRec = dp.cache(function(state, timeLeft, otherParams, topLevel) {
    debug("actRec(" + stateToStringShort(state) + ", " + timeLeft + ", " + otherParams + ")")
    // var belief = belief(state)
    var alpha = (state.turn == selfRole) ? selfParams.alpha : 
      ((otherParams === undefined) ? expectation(marginalize(belief(state), 'alpha')) : otherParams.alpha)
    return Infer({method: 'enumerate'}, function() {
      var actions = game.actions
      var action = uniformDraw(actions(state))
      var eu = expectedUtility(state, action, state.turn, timeLeft, otherParams, topLevel)
      factor(alpha * eu)
      return action
    })
  })

  /** Computes expected utility of agent with *role* upon *action* taken in *state*
    * with *timeLeft* left
  */
  var expectedUtility = dp.cache(function(state, action, role, timeLeft, otherParams, topLevel) {
    debug("expectedUtility(" + stateToStringShort(state) + ", " + action + ", " + role + ", " + timeLeft + ")")
    var start = _.now()
    var u = utility(state, action, role, otherParams)
    var nextTimeLeft = timeLeft - 1
    if (nextTimeLeft == 0) {
      return u
    }
    var nextState = transition(state, action)
    // var belief = belief(state)
    var discountFactor = (role == selfRole) ? selfParams.discountFactor : 
      ((otherParams === undefined) ? expectation(marginalize(belief(state), 'discountFactor')) : otherParams.discountFactor)
    var eu = u + discountFactor * expectation(Infer({method: 'enumerate'}, function() {
      var nextAction = sample(actRec(nextState, nextTimeLeft, otherParams))
      return expectedUtility(nextState, nextAction, role, nextTimeLeft, otherParams) 
    }))
    if (topLevel) {
      display("[" + action + "," + timeLeft + "," + role + "," + state.investments + 
        "," + state.returns + "]. Took " + (_.now() - start) + ". EU=" + eu)
      display("Trusts at the next state.")
      // var nextState = transition(state, action)
      display("Investor: " + expectation(trust(state, action).investor))
      display("Investee: " + expectation(trust(state, action).investee))
    }
    return eu
  })
  return { params: selfParams, act, expectedUtility, belief}
}